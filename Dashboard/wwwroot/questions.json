[
    {
        "Id": 1,
        "Question": "Quelle est la différence entre un type valeur et un type référence en C# ?",
        "Choices": [
            "Les types valeur sont stockés sur la pile, les types référence sur le tas.",
            "Les types référence sont plus rapides à accéder.",
            "Les types valeur ne peuvent pas être modifiés.",
            "Il n'y a pas de différence."
        ],
        "CorrectAnswer": 0,
        "Explanation": "Les types valeur (comme int, bool) sont stockés sur la pile, tandis que les types référence (comme les objets) sont stockés sur le tas."
    },
    {
        "Id": 2,
        "Question": "Qu'est-ce que la compilation Just-In-Time (JIT) en C# ?",
        "Choices": [
            "Une compilation qui a lieu avant l'exécution du programme.",
            "Une compilation qui a lieu pendant l'exécution du programme.",
            "Une compilation qui ne se produit qu'en cas d'exception.",
            "Une compilation qui optimise le code pour la machine cible."
        ],
        "CorrectAnswer": 1,
        "Explanation": "La compilation Just-In-Time (JIT) se produit pendant l'exécution du programme, convertissant le code IL en code natif à la volée."
    },
    {
        "Id": 3,
        "Question": "Quelle est la différence entre == et .Equals en C# ?",
        "Choices": [
            "== compare les références, .Equals compare les valeurs logiques.",
            "== et .Equals font exactement la même chose.",
            ".Equals compare uniquement les chaînes de caractères.",
            "== est plus performant que .Equals."
        ],
        "CorrectAnswer": 0,
        "Explanation": "L'opérateur == compare les références pour les types référence et les valeurs pour les types valeur, tandis que la méthode .Equals est utilisée pour comparer les valeurs logiques des objets."
    },
    {
        "Id": 4,
        "Question": "Qu'est-ce que l'unboxing en C# ?",
        "Choices": [
            "L'unboxing est la conversion d'un type valeur en type référence.",
            "L'unboxing est la conversion d'un type référence en type valeur.",
            "L'unboxing est un mécanisme de sérialisation.",
            "L'unboxing est la conversion d'un type dynamique en type valeur."
        ],
        "CorrectAnswer": 1,
        "Explanation": "L'unboxing est le processus de conversion d'un type référence contenant une valeur de type valeur (boxing) en son type valeur sous-jacent."
    },
    {
        "Id": 5,
        "Question": "Qu'est-ce que le data binding en Angular ?",
        "Choices": [
            "Un mécanisme pour synchroniser les données entre modèle et vue.",
            "Un mécanisme pour afficher les données d'une API.",
            "Un mécanisme pour gérer les événements utilisateur.",
            "Un mécanisme pour sécuriser les données."
        ],
        "CorrectAnswer": 0,
        "Explanation": "Le data binding est un mécanisme qui permet de lier les données entre le modèle et la vue, facilitant la synchronisation automatique des données entre eux."
    },
    {
        "Id": 6,
        "Question": "Quelles sont les nouveautés principales de C# 10 ?",
        "Choices": [
            "Global using directives, record structs, interpolated string handlers.",
            "Dynamic types, pattern matching.",
            "LINQ, async/await.",
            "Nouvelle syntaxe de boucles."
        ],
        "CorrectAnswer": 0,
        "Explanation": "C# 10 introduit des fonctionnalités telles que les global using directives, les record structs, et les interpolated string handlers."
    },
    {
        "Id": 7,
        "Question": "Quelle est la différence entre INNER JOIN et LEFT JOIN en SQL ?",
        "Choices": [
            "INNER JOIN retourne uniquement les lignes correspondantes, LEFT JOIN inclut toutes les lignes de gauche.",
            "INNER JOIN inclut toutes les lignes des deux tables.",
            "LEFT JOIN exclut les lignes sans correspondance.",
            "LEFT JOIN est plus rapide qu'INNER JOIN."
        ],
        "CorrectAnswer": 0,
        "Explanation": "INNER JOIN retourne uniquement les lignes ayant des correspondances dans les deux tables, tandis que LEFT JOIN retourne toutes les lignes de la table de gauche, même sans correspondance dans la table de droite."
    },
    {
        "Id": 8,
        "Question": "Quelle est la différence entre une classe partielle, abstraite et une interface en C# ?",
        "Choices": [
            "Une classe partielle peut être définie sur plusieurs fichiers, une classe abstraite peut contenir une implémentation partielle, et une interface ne contient que des contrats.",
            "Une classe partielle est similaire à une interface.",
            "Une interface peut contenir de l'implémentation partielle.",
            "Une classe abstraite ne peut pas être héritée."
        ],
        "CorrectAnswer": 0,
        "Explanation": "Une classe partielle permet de diviser son implémentation en plusieurs fichiers, une classe abstraite sert de base pour d'autres classes et peut contenir une implémentation partielle, tandis qu'une interface définit uniquement des contrats sans implémentation."
    },
    {
        "Id": 9,
        "Question": "Quel design pattern est illustré par ce code en C# ?\n```csharp\npublic class Singleton\n{\n    private static Singleton _instance;\n    private Singleton() {}\n    public static Singleton Instance => _instance ??= new Singleton();\n}\n```",
        "Choices": [
            "Factory",
            "Singleton",
            "Observer",
            "Decorator"
        ],
        "CorrectAnswer": 1,
        "Explanation": "Le code montre une implémentation typique du pattern Singleton, où une seule instance de la classe est partagée."
    },
    {
        "Id": 10,
        "Question": "Quel design pattern est illustré par ce code en C# ?\n```csharp\npublic abstract class Product\n{\n    public abstract string GetName();\n}\n\npublic class ConcreteProduct : Product\n{\n    public override string GetName() => \"Produit concret\";\n}\n\npublic abstract class Creator\n{\n    public abstract Product FactoryMethod();\n}\n\npublic class ConcreteCreator : Creator\n{\n    public override Product FactoryMethod() => new ConcreteProduct();\n}\n```",
        "Choices": [
            "Abstract Factory",
            "Factory Method",
            "Builder",
            "Prototype"
        ],
        "CorrectAnswer": 1,
        "Explanation": "Le code illustre le pattern Factory Method, où une méthode abstraite dans une classe créatrice est implémentée par des sous-classes pour créer des objets spécifiques."
    },
    {
        "Id": 11,
        "Question": "Quel design pattern est illustré par ce code en C# ?\\n```csharp\\npublic interface IObserver\\n{\\n    void Update(string message);\\n}\\n\\npublic class ConcreteObserver : IObserver\\n{\\n    public void Update(string message)\\n    {\\n        Console.WriteLine(\\$\\\"Notification reçue : {message}\\\");\\n    }\\n}\\n\\npublic class Subject\\n{\\n    private List<IObserver> _observers = new List<IObserver>();\\n\\n    public void Attach(IObserver observer) => _observers.Add(observer);\\n    public void Notify(string message)\\n    {\\n        foreach (var observer in _observers)\\n            observer.Update(message);\\n    }\\n}\\n```",
        "Choices": [
            "Observer",
            "Decorator",
            "Mediator",
            "Strategy"
        ],
        "CorrectAnswer": 0,
        "Explanation": "Le code montre une implémentation du pattern Observer, où des objets abonnés (observers) sont notifiés par le sujet principal (subject) lorsqu'un événement se produit."
    },
    {
        "Id": 12,
        "Question": "Quelle est la sortie de cette fonction pour un arbre binaire donné ?\n```python\ndef reverse_tree(root):\n    if not root:\n        return None\n    root.left, root.right = reverse_tree(root.right), reverse_tree(root.left)\n    return root\n```\nConsidérez un arbre binaire initialement équilibré avec les nœuds 1, 2, 3.",
        "Choices": [
            "Un arbre avec les enfants inversés.",
            "Un arbre avec les valeurs doublées.",
            "Un arbre non modifié.",
            "Une erreur car la fonction est incorrecte."
        ],
        "CorrectAnswer": 0,
        "Explanation": "La fonction inverse les sous-arbres gauche et droit de chaque nœud de l'arbre. La sortie est donc un arbre avec les enfants inversés."
    },
    {
        "Id": 13,
        "Question": "Quel est l'état final du tableau après l'exécution de ce code ?\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\narr = [64, 34, 25, 12, 22, 11, 90]\nbubble_sort(arr)\n```",
        "Choices": [
            "[11, 12, 22, 25, 34, 64, 90]",
            "[90, 64, 34, 25, 22, 12, 11]",
            "[64, 34, 25, 12, 22, 11, 90]",
            "Erreur car le tableau n'est pas trié."
        ],
        "CorrectAnswer": 0,
        "Explanation": "Le tri à bulles effectue des échanges successifs pour trier le tableau en ordre croissant. Le tableau final est [11, 12, 22, 25, 34, 64, 90]."
    },
    {
        "Id": 14,
        "Question": "La fonction suivante détermine si une chaîne est un palindrome. Quelle est la sortie pour la chaîne \"radar\" ?\n```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\nprint(is_palindrome(\"radar\"))\n```",
        "Choices": [
            "True",
            "False",
            "Erreur",
            "None"
        ],
        "CorrectAnswer": 0,
        "Explanation": "La fonction compare la chaîne originale avec sa version inversée. Comme \"radar\" est un palindrome, la sortie est True."
    },
    {
        "Id": 15,
        "Question": "Quelle est la sortie de cet appel récursif pour n=5 ?\n```python\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(5))\n```",
        "Choices": [
            "5",
            "8",
            "13",
            "Erreur"
        ],
        "CorrectAnswer": 1,
        "Explanation": "La fonction calcule la suite de Fibonacci de manière récursive. Pour n=5, la sortie est 5+3=8."
    },
    {
        "Id": 16,
        "Question": "Quelle est la valeur de retour de cette fonction ?\n```python\ndef find_max(arr):\n    max_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n    return max_val\n\narr = [3, 5, 2, 9, 6]\nfind_max(arr)\n```",
        "Choices": [
            "9",
            "6",
            "5",
            "3"
        ],
        "CorrectAnswer": 0,
        "Explanation": "La fonction trouve la valeur maximale dans un tableau en parcourant chaque élément. La valeur maximale dans [3, 5, 2, 9, 6] est 9."
    }
]
